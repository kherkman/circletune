<!DOCTYPE html>
<html lang="fi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Futuristic Orbital Synth EDO</title>
    <style>
        :root {
            --bg-color: #050505;
            --panel-bg: #111;
            --text-color: #eee;
            --accent: #00f3ff;
            --accent-active: #ff0055;
            --border: #333;
            --wheel-bg: #1a1a1a;
            --wheel-groove: #000;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
            touch-action: none;
            user-select: none;
        }

        /* Yläpalkki */
        #controls {
            background-color: var(--panel-bg);
            padding: 5px 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            z-index: 10;
            border-bottom: 1px solid var(--border);
            font-size: 0.75rem;
            min-height: 80px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
            align-items: center;
        }

        .separator {
            width: 1px;
            height: 40px;
            background: #333;
            margin: 0 5px;
        }

        label {
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #888;
        }

        input, select, button {
            background: #222;
            color: var(--text-color);
            border: 1px solid #444;
            border-radius: 4px;
            font-size: 0.75rem;
            padding: 4px;
            outline: none;
        }

        /* Range Slider */
        input[type="range"] {
            -webkit-appearance: none;
            width: 80px;
            height: 4px;
            background: #333;
            border: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
        }

        /* Buttonit */
        button {
            cursor: pointer;
            font-weight: bold;
            text-transform: uppercase;
            color: var(--accent);
            transition: all 0.2s;
            min-width: 60px;
        }
        button:hover { background: #333; box-shadow: 0 0 5px var(--accent); }
        button.active { background: var(--accent-active); border-color: var(--accent-active); color: #fff; }

        /* WHEELS (Pyörät) */
        .wheel-container {
            display: flex;
            gap: 10px;
            padding: 0 10px;
        }
        .wheel-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }
        .wheel {
            width: 30px;
            height: 60px;
            background: linear-gradient(to bottom, 
                var(--wheel-bg) 0%, 
                var(--wheel-groove) 10%, 
                var(--wheel-bg) 20%, 
                var(--wheel-groove) 30%, 
                var(--wheel-bg) 40%, 
                var(--wheel-groove) 50%, 
                var(--wheel-bg) 60%, 
                var(--wheel-groove) 70%, 
                var(--wheel-bg) 80%, 
                var(--wheel-groove) 90%, 
                var(--wheel-bg) 100%
            );
            border: 2px solid #444;
            border-radius: 4px;
            position: relative;
            cursor: ns-resize;
            box-shadow: inset 0 0 10px #000;
        }
        .wheel-mark {
            position: absolute;
            left: 0; right: 0;
            height: 2px;
            background: var(--accent);
            box-shadow: 0 0 5px var(--accent);
            pointer-events: none;
        }
        
        /* Canvas */
        #canvas-container {
            flex-grow: 1;
            position: relative;
            cursor: crosshair;
            overflow: hidden;
            width: 100%;
        }
        canvas { 
            display: block; 
            width: 100%;
            height: 100%;
        }

        /* Overlay */
        #start-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.92);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 100;
        }
        h1 {
            font-weight: 300;
            letter-spacing: 4px;
            text-shadow: 0 0 10px var(--accent);
            margin-bottom: 20px;
            text-align: center;
        }
        .status {
            font-size: 0.7rem;
            color: #ff9900;
            margin-left: 5px;
            white-space: nowrap;
        }
    </style>
    <!-- SF2 Library -->
    <script type="module">
        import { SpessaSynth } from 'https://esm.sh/spessasynth_lib@1.0.8';
        window.SpessaSynthLib = SpessaSynth;
    </script>
</head>
<body>

<div id="controls">
    <!-- WHEELS -->
    <div class="wheel-container">
        <div class="wheel-wrapper">
            <div id="bendWheel" class="wheel"><div class="wheel-mark" style="top: 50%;"></div></div>
            <label>Bend</label>
        </div>
        <div class="wheel-wrapper">
            <div id="modWheel" class="wheel"><div class="wheel-mark" style="top: 100%;"></div></div>
            <label>Mod</label>
        </div>
    </div>

    <div class="separator"></div>

    <!-- SETTINGS -->
    <div class="control-group">
        <label>Zoom</label>
        <input type="range" id="zoomSlider" min="0.5" max="2.5" step="0.1" value="1.0">
    </div>
    
    <div class="control-group">
        <label>Mode</label>
        <div style="display:flex; gap:5px;">
            <button id="notesBtn">Notes</button>
            <button id="invertBtn">Invert</button>
        </div>
    </div>

    <div class="control-group">
        <label>EDO</label>
        <input type="number" id="edoInput" value="12" min="1" max="96" style="width: 40px; text-align: center;">
    </div>

    <div class="separator"></div>

    <!-- SOUND & MIDI -->
    <div class="control-group">
        <label>MIDI Out</label>
        <select id="midiSelect" style="width: 100px;">
            <option value="">- Off -</option>
        </select>
    </div>

    <div class="control-group">
        <label>Sample / SF2</label>
        <div style="display:flex; flex-direction:column; gap:2px;">
            <input type="file" id="sampleInput" accept="audio/*" style="width: 130px;">
            <input type="file" id="sf2Input" accept=".sf2" style="width: 130px;">
        </div>
    </div>
    
    <div class="control-group">
        <label>Base Hz</label>
        <input type="number" id="baseFreqInput" value="261.63" step="1" style="width: 50px;">
    </div>
    
    <div class="status" id="statusText">Valmis</div>
</div>

<div id="canvas-container">
    <canvas id="synthCanvas"></canvas>
    <div id="start-overlay">
        <h1>ORBITAL EDO SYNTH</h1>
        <button id="startBtn" style="font-size: 1.2rem; padding: 15px 30px;">KÄYNNISTÄ</button>
        <p style="margin-top: 20px; font-size: 0.9em; color: #888;">Multi-touch &bull; EDO &bull; Wheels</p>
    </div>
</div>

<script>
    /**
     * KONFIGURAATIO
     */
    const CIRCLE_COUNT = 10;
    const BASE_OCTAVE_HIGH = 8; 
    const LOWEST_OCTAVE = -1;
    const NOTE_NAMES = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
    
    // Global State
    let state = {
        edo: 12,
        snapToGrid: false,
        invertOctaves: false,
        zoom: 1.0,
        baseFreq: 261.63,
        bend: 0, // -1 ... 1
        mod: 0   // 0 ... 1
    };

    // Audio Context
    let audioCtx;
    let mainGain;
    let customBuffer = null;
    let sf2Synth = null;
    let sf2Loaded = false;
    
    // Vibrato LFO (Global)
    let vibratoLfo = null;
    let vibratoGain = null;

    // MIDI
    let midiAccess = null;
    let midiOutput = null;
    const midiChannels = new Array(16).fill(false);

    // Canvas
    let canvas, ctx;
    let width, height, centerX, centerY, baseRadius;
    const activeVoices = new Map();

    // UI Elements
    const statusText = document.getElementById('statusText');
    const edoInput = document.getElementById('edoInput');
    const notesBtn = document.getElementById('notesBtn');

    // --- AUDIO & MIDI SETUP ---

    async function initAudio() {
        if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            mainGain = audioCtx.createGain();
            mainGain.gain.value = 0.4;
            mainGain.connect(audioCtx.destination);

            // Alusta LFO
            vibratoLfo = audioCtx.createOscillator();
            vibratoLfo.frequency.value = 6.0; 
            vibratoGain = audioCtx.createGain();
            vibratoGain.gain.value = 0;
            
            vibratoLfo.connect(vibratoGain);
            vibratoLfo.start();
        }
        if (audioCtx.state === 'suspended') await audioCtx.resume();
        
        // MIDI Init
        if (navigator.requestMIDIAccess) {
            try {
                midiAccess = await navigator.requestMIDIAccess();
                populateMidiDropdown();
                midiAccess.onstatechange = populateMidiDropdown;
                statusText.innerText = "Audio & MIDI OK";
            } catch (e) {
                statusText.innerText = "MIDI ei saatavilla";
            }
        }
    }

    function populateMidiDropdown() {
        const select = document.getElementById('midiSelect');
        const current = select.value;
        select.innerHTML = '<option value="">- Off -</option>';
        if (!midiAccess) return;
        for (let output of midiAccess.outputs.values()) {
            const opt = document.createElement('option');
            opt.value = output.id;
            opt.text = output.name;
            select.appendChild(opt);
        }
        if(current) select.value = current;
    }

    // --- WHEEL LOGIC ---

    function initWheels() {
        const bendEl = document.getElementById('bendWheel');
        const modEl = document.getElementById('modWheel');
        const bendMark = bendEl.querySelector('.wheel-mark');
        const modMark = modEl.querySelector('.wheel-mark');

        const getVal = (e, el) => {
            const rect = el.getBoundingClientRect();
            let val = 1 - (e.clientY - rect.top) / rect.height; 
            return Math.max(0, Math.min(1, val));
        };

        // BEND (Spring back)
        let isBending = false;
        const updateBend = (val) => {
            state.bend = (val - 0.5) * 2; 
            const pct = (1 - val) * 100;
            bendMark.style.top = `${pct}%`;
            updateAllVoicesPitch();
            sendMidiPitchBendGlobal();
        };

        bendEl.addEventListener('mousedown', (e) => { isBending = true; updateBend(getVal(e, bendEl)); });
        window.addEventListener('mousemove', (e) => { if (isBending) updateBend(getVal(e, bendEl)); });
        window.addEventListener('mouseup', () => {
            if (isBending) {
                isBending = false;
                bendMark.style.transition = "top 0.2s ease-out";
                bendMark.style.top = "50%";
                state.bend = 0;
                setTimeout(() => bendMark.style.transition = "", 200);
                updateAllVoicesPitch();
                sendMidiPitchBendGlobal();
            }
        });

        // MOD (Stay put)
        let isModding = false;
        const updateMod = (val) => {
            state.mod = val; 
            const pct = (1 - val) * 100;
            modMark.style.top = `${pct}%`;
            if (vibratoGain) {
                vibratoGain.gain.setTargetAtTime(val * 50, audioCtx.currentTime, 0.05); 
            }
            sendMidiModWheel();
        };

        modEl.addEventListener('mousedown', (e) => { isModding = true; updateMod(getVal(e, modEl)); });
        window.addEventListener('mousemove', (e) => { if (isModding) updateMod(getVal(e, modEl)); });
        window.addEventListener('mouseup', () => { isModding = false; });
    }

    // --- CALCULATIONS ---

    function calculateParams(x, y) {
        const dx = x - centerX;
        const dy = y - centerY;
        const radius = Math.sqrt(dx*dx + dy*dy);
        const angle = Math.atan2(dy, dx); 
        const currentMaxRadius = baseRadius * state.zoom;
        const step = currentMaxRadius / CIRCLE_COUNT;
        
        // Ring Index
        let ringIndex = Math.floor(radius / step);
        if (ringIndex >= CIRCLE_COUNT) ringIndex = CIRCLE_COUNT - 1;
        if (ringIndex < 0) ringIndex = 0;

        // Octave
        let octave;
        if (state.invertOctaves) {
            octave = LOWEST_OCTAVE + ringIndex;
        } else {
            octave = BASE_OCTAVE_HIGH - ringIndex;
        }

        // Angle -> Steps
        let normalizedAngle = (angle + Math.PI / 2); 
        if (normalizedAngle < 0) normalizedAngle += Math.PI * 2;
        
        // EDO Calculation
        const fraction = normalizedAngle / (Math.PI * 2);
        let steps = fraction * state.edo;

        // Visual Coordinates Logic
        let visualX = x;
        let visualY = y;

        // SNAP (NOTES mode)
        if (state.snapToGrid) {
            steps = Math.round(steps);
            if (steps === state.edo) steps = 0;
            
            // Recalculate Angle based on snapped steps
            const snappedAngle = (steps / state.edo) * Math.PI * 2 - Math.PI / 2;
            
            // Recalculate Radius based on ring center
            // (ringIndex + 1) * step is the outer edge, let's stick to the edge like the grid lines
            const snappedRadius = (ringIndex + 1) * step;

            visualX = centerX + Math.cos(snappedAngle) * snappedRadius;
            visualY = centerY + Math.sin(snappedAngle) * snappedRadius;
        }

        const totalSteps = (octave * state.edo) + steps;
        
        // Frequency Formula
        const baseC = 16.35; 
        let freq = baseC * Math.pow(2, totalSteps / state.edo);

        return { 
            radius, 
            angle, 
            freq, 
            steps,
            visualX, 
            visualY 
        };
    }

    function applyBend(freq) {
        // +/- 2 semitones range
        const bendRangeOctaves = 2 / 12; 
        return freq * Math.pow(2, state.bend * bendRangeOctaves);
    }

    // --- VOICE CLASS ---

    class Voice {
        constructor(id, data) {
            this.id = id;
            this.baseFreq = data.freq;
            
            // Visuals
            this.visualX = data.visualX;
            this.visualY = data.visualY;

            this.source = null;
            this.gain = null;
            this.filter = null;
            
            this.midiChannel = null;
            this.lastMidiNote = null;
            this.sf2Note = null;

            this.start();
        }

        getEffectiveFreq() {
            return applyBend(this.baseFreq);
        }

        start() {
            const freq = this.getEffectiveFreq();

            // MIDI Channel Alloc
            if (midiOutput) {
                const ch = midiChannels.findIndex(c => !c);
                if (ch !== -1) {
                    this.midiChannel = ch;
                    midiChannels[ch] = true;
                    this.sendMidi(freq, true);
                }
            }

            // SF2
            if (sf2Loaded && sf2Synth) {
                const midiNote = Math.round(69 + 12 * Math.log2(freq / 440));
                this.sf2Note = midiNote;
                sf2Synth.noteOn(0, midiNote, 100);
                return;
            }

            // Web Audio
            this.gain = audioCtx.createGain();
            this.gain.connect(mainGain);
            this.gain.gain.value = 0.2;

            if (customBuffer) {
                this.source = audioCtx.createBufferSource();
                this.source.buffer = customBuffer;
                this.source.loop = true;
                this.source.playbackRate.value = freq / state.baseFreq;
                this.source.connect(this.gain);
                this.source.start(0);
            } else {
                this.source = audioCtx.createOscillator();
                this.source.type = 'sawtooth';
                this.source.frequency.value = freq;
                
                if (vibratoGain) vibratoGain.connect(this.source.frequency);

                this.filter = audioCtx.createBiquadFilter();
                this.filter.type = 'lowpass';
                this.filter.frequency.value = freq * 4;

                this.source.connect(this.filter);
                this.filter.connect(this.gain);
                this.source.start(0);
            }
        }

        update(data) {
            this.baseFreq = data.freq;
            this.visualX = data.visualX;
            this.visualY = data.visualY;
            this.refreshPitch();
        }

        refreshPitch() {
            const freq = this.getEffectiveFreq();
            
            if (this.midiChannel !== null && midiOutput) {
                this.sendMidi(freq, false);
            }

            if (sf2Loaded && sf2Synth) {
                 const midiNote = Math.round(69 + 12 * Math.log2(freq / 440));
                 if (midiNote !== this.sf2Note) {
                     sf2Synth.noteOff(0, this.sf2Note);
                     sf2Synth.noteOn(0, midiNote, 100);
                     this.sf2Note = midiNote;
                 }
                 return;
            }

            if (this.source && !sf2Loaded) {
                const now = audioCtx.currentTime;
                if (customBuffer) {
                    let rate = freq / state.baseFreq;
                    rate = Math.max(0.01, Math.min(20, rate));
                    this.source.playbackRate.setTargetAtTime(rate, now, 0.02);
                } else {
                    this.source.frequency.setTargetAtTime(freq, now, 0.02);
                    if(this.filter) this.filter.frequency.setTargetAtTime(freq * 4, now, 0.02);
                }
            }
        }

        sendMidi(freq, isStart) {
            const exactNote = 69 + 12 * Math.log2(freq / 440);
            const noteIndex = Math.round(exactNote);
            const delta = exactNote - noteIndex; 
            const bendVal = Math.floor(8192 + (delta / 2) * 8192);
            const clamped = Math.max(0, Math.min(16383, bendVal));
            const lsb = clamped & 0x7F;
            const msb = (clamped >> 7) & 0x7F;

            const ch = this.midiChannel;
            midiOutput.send([0xE0 + ch, lsb, msb]);

            if (isStart || noteIndex !== this.lastMidiNote) {
                if (!isStart && this.lastMidiNote !== null) {
                    midiOutput.send([0x80 + ch, this.lastMidiNote, 0]);
                }
                midiOutput.send([0x90 + ch, noteIndex, 100]);
                this.lastMidiNote = noteIndex;
            }
        }

        stop() {
            if (this.midiChannel !== null && midiOutput) {
                midiOutput.send([0x80 + this.midiChannel, this.lastMidiNote, 0]);
                midiOutput.send([0xE0 + this.midiChannel, 0x00, 0x40]); 
                midiChannels[this.midiChannel] = false;
            }

            if (sf2Loaded && sf2Synth && this.sf2Note) {
                sf2Synth.noteOff(0, this.sf2Note);
            }

            if (this.source) {
                if (vibratoGain && !customBuffer) {
                    try { vibratoGain.disconnect(this.source.frequency); } catch(e){}
                }
                const now = audioCtx.currentTime;
                if(this.gain) this.gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                this.source.stop(now + 0.15);
                setTimeout(() => {
                    this.source?.disconnect();
                    this.gain?.disconnect();
                    this.filter?.disconnect();
                }, 200);
            }
        }
    }

    function updateAllVoicesPitch() {
        activeVoices.forEach(v => v.refreshPitch());
    }

    function sendMidiPitchBendGlobal() {
        // MPE handles pitch bend per channel
    }

    function sendMidiModWheel() {
        if (!midiOutput) return;
        const val7bit = Math.floor(state.mod * 127);
        for(let i=0; i<16; i++) {
            if (midiChannels[i]) {
                midiOutput.send([0xB0 + i, 1, val7bit]);
            }
        }
    }


    // --- VISUAL LOOP ---

    function initCanvas() {
        canvas = document.getElementById('synthCanvas');
        ctx = canvas.getContext('2d');
        const container = document.getElementById('canvas-container');

        // ResizeObserver korjaa kursorin "offset" ongelman
        // Varmistaa että canvasin sisäinen resoluutio on 1:1 ruudun kanssa
        const observer = new ResizeObserver(entries => {
            for (let entry of entries) {
                const width = Math.floor(entry.contentRect.width);
                const height = Math.floor(entry.contentRect.height);
                canvas.width = width;
                canvas.height = height;
                resize();
            }
        });
        observer.observe(container);
        
        // Initial resize
        resize();

        // INPUT HANDLERS
        const start = (id, x, y) => {
            if(!audioCtx) return;
            // Haetaan koordinaatit varmasti oikein suhteessa canvasin nykyiseen sijaintiin
            const rect = canvas.getBoundingClientRect();
            const relX = x - rect.left;
            const relY = y - rect.top;

            const data = calculateParams(relX, relY);
            const limit = baseRadius * state.zoom * 1.1;
            if (data.radius > limit) return;
            activeVoices.set(id, new Voice(id, data));
        };
        const move = (id, x, y) => {
            if (activeVoices.has(id)) {
                const rect = canvas.getBoundingClientRect();
                const relX = x - rect.left;
                const relY = y - rect.top;

                const data = calculateParams(relX, relY);
                activeVoices.get(id).update(data);
            }
        };
        const end = (id) => {
            if (activeVoices.has(id)) {
                activeVoices.get(id).stop();
                activeVoices.delete(id);
            }
        };

        // Event Listeners
        canvas.addEventListener('mousedown', e => start('m', e.clientX, e.clientY));
        window.addEventListener('mousemove', e => move('m', e.clientX, e.clientY));
        window.addEventListener('mouseup', () => end('m'));
        
        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            for(let i=0; i<e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                start(t.identifier, t.clientX, t.clientY);
            }
        }, {passive:false});
        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            for(let i=0; i<e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                move(t.identifier, t.clientX, t.clientY);
            }
        }, {passive:false});
        const touchEnd = e => {
            e.preventDefault();
            for(let i=0; i<e.changedTouches.length; i++) end(e.changedTouches[i].identifier);
        };
        canvas.addEventListener('touchend', touchEnd);
        canvas.addEventListener('touchcancel', touchEnd);
    }

    function resize() {
        const container = document.getElementById('canvas-container');
        width = canvas.width;
        height = canvas.height;
        centerX = width/2;
        centerY = height/2;
        baseRadius = Math.min(width, height) / 2 * 0.95;
    }

    function animate() {
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg-color');
        ctx.fillRect(0, 0, width, height);

        const currentMaxR = baseRadius * state.zoom;
        const step = currentMaxR / CIRCLE_COUNT;

        // Gradient Background
        const grad = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, currentMaxR);
        grad.addColorStop(0, '#111');
        grad.addColorStop(1, '#000');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(centerX, centerY, currentMaxR, 0, Math.PI*2);
        ctx.fill();

        // SECTOR LINES (Based on EDO)
        ctx.strokeStyle = '#222';
        ctx.lineWidth = 1;
        for (let i = 0; i < state.edo; i++) {
            const angle = (i / state.edo) * Math.PI * 2 - Math.PI / 2;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(centerX + Math.cos(angle)*currentMaxR, centerY + Math.sin(angle)*currentMaxR);
            ctx.stroke();

            // Labels (Show note names only if EDO=12 and not playing)
            if (activeVoices.size === 0 && state.edo === 12) {
                const labelR = currentMaxR + 20;
                if (labelR < Math.max(width,height)) {
                    ctx.fillStyle = '#444';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(NOTE_NAMES[i], centerX + Math.cos(angle)*labelR, centerY + Math.sin(angle)*labelR);
                }
            }
        }

        // CIRCLES
        for (let i = 0; i < CIRCLE_COUNT; i++) {
            const r = (i + 1) * step;
            if (r > Math.max(width, height)*1.5) continue;
            
            ctx.beginPath();
            ctx.arc(centerX, centerY, r, 0, Math.PI * 2);
            ctx.strokeStyle = '#333';
            ctx.stroke();

            // NOTES DOTS (If active)
            if (state.snapToGrid) {
                ctx.fillStyle = '#222';
                for (let j = 0; j < state.edo; j++) {
                    const angle = (j / state.edo) * Math.PI * 2 - Math.PI / 2;
                    const x = centerX + Math.cos(angle) * r;
                    const y = centerY + Math.sin(angle) * r;
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, Math.PI*2);
                    ctx.fill();
                }
            }

            // Octave Labels
            if ((i===0 || i===CIRCLE_COUNT-1) && r < Math.min(width,height)) {
                ctx.fillStyle = '#666';
                ctx.font = '10px monospace';
                let txt = "";
                if(i===0) txt = state.invertOctaves ? "LOW" : "HIGH";
                if(i===CIRCLE_COUNT-1) txt = state.invertOctaves ? "HIGH" : "LOW";
                ctx.fillText(txt, centerX + 5, centerY - r + 10);
            }
        }

        // ACTIVE VOICES
        activeVoices.forEach(v => {
            // Use visual coordinates (snapped or raw)
            const vx = v.visualX;
            const vy = v.visualY;

            ctx.beginPath();
            ctx.arc(vx, vy, 15, 0, Math.PI*2);
            ctx.fillStyle = 'var(--accent-active)';
            ctx.shadowBlur = 15;
            ctx.shadowColor = 'var(--accent-active)';
            ctx.fill();
            ctx.shadowBlur = 0;

            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(vx, vy);
            ctx.strokeStyle = 'rgba(255,0,85,0.5)';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Text Info
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 12px Arial';
            const freq = v.getEffectiveFreq();
            ctx.fillText(`${Math.round(freq)}Hz`, vx + 20, vy);
        });

        requestAnimationFrame(animate);
    }

    // --- UI EVENT LISTENERS ---

    document.getElementById('startBtn').addEventListener('click', async () => {
        document.getElementById('start-overlay').style.display = 'none';
        await initAudio();
        initWheels();
        initCanvas();
        animate();
    });

    document.getElementById('zoomSlider').addEventListener('input', e => {
        state.zoom = parseFloat(e.target.value);
        resize(); // Force recalc for calculateParams limit check
    });
    
    document.getElementById('invertBtn').addEventListener('click', e => {
        state.invertOctaves = !state.invertOctaves;
        e.target.classList.toggle('active', state.invertOctaves);
    });

    notesBtn.addEventListener('click', () => {
        state.snapToGrid = !state.snapToGrid;
        notesBtn.classList.toggle('active', state.snapToGrid);
    });

    edoInput.addEventListener('change', e => {
        let val = parseInt(e.target.value);
        if(val < 1) val = 1;
        if(val > 96) val = 96;
        state.edo = val;
    });

    document.getElementById('baseFreqInput').addEventListener('input', e => state.baseFreq = parseFloat(e.target.value) || 261.63);
    document.getElementById('midiSelect').addEventListener('change', e => {
        if (!midiAccess) return;
        midiOutput = e.target.value ? midiAccess.outputs.get(e.target.value) : null;
    });

    // File inputs
    document.getElementById('sampleInput').addEventListener('change', function(e) {
        const f = e.target.files[0];
        if(!f) return;
        sf2Loaded = false;
        const r = new FileReader();
        r.onload = ev => {
            if(!audioCtx) audioCtx = new AudioContext();
            audioCtx.decodeAudioData(ev.target.result, b => {
                customBuffer = b;
                statusText.innerText = "Sample ladattu";
            });
        };
        r.readAsArrayBuffer(f);
    });

    document.getElementById('sf2Input').addEventListener('change', function(e) {
        const f = e.target.files[0];
        if(!f) return;
        const r = new FileReader();
        r.onload = ev => {
            if(!audioCtx) audioCtx = new AudioContext();
            try {
                sf2Synth = new window.SpessaSynthLib.Synthesizer(audioCtx.destination, ev.target.result);
                sf2Loaded = true;
                statusText.innerText = "SF2 ladattu";
            } catch(err) { console.error(err); }
        };
        r.readAsArrayBuffer(f);
    });

</script>
</body>
</html>
